// pnltri.js / raw.github.com/jahting/pnltri.js/master/LICENSE

const r = { ca: '2.1.1' };
r.c = {
  random: Math.random,
  da(b) {
    for (let c = b.length - 1; c > 0; c--) {
      let l = Math.floor(r.c.random() * (c + 1));

      var k = b[c];
      b[c] = b[l];
      b[l] = k;
    }
    return b;
  },
  G(b, c) {
    let l = b.y - c.y;
    if (l < r.c.D) return -1;
    if (l > r.c.n) return 1;
    l = b.x - c.x;
    return l < r.c.D ? -1 : l > r.c.n ? 1 : 0;
  },
  N(b, c, l) {
    return (c.x - b.x) * (l.y - b.y) - (c.y - b.y) * (l.x - b.x);
  },
};
r.c.n = Math.pow(2, -43);
r.c.D = -r.c.n;
function u(b) {
  this.U = [];
  this.r = [];
  this.X = [];
  this.L = 0;
  this.F = [];
  this.R = [];
  this.T = [];
  if (b)
    for (let c = 0, l = b.length; c < l; c++) {
      const k = w(this, b[c]);
      if (k.length < 3) console.log('Polygon has < 3 vertices!', k);
      else {
        for (
          var a = void 0, e = void 0, d = void 0, f = 0;
          f < k.length - 1;
          f++
        )
          (a = x(this, k[f], k[f + 1])),
            d ? ((a.o = d), (d.m = a)) : (e = a),
            (d = a),
            this.r.push(a);
        a = x(this, k[k.length - 1], k[0]);
        a.o = d;
        d.m = a;
        this.r.push(a);
        e.o = a;
        a.m = e;
        this.F[this.L++] = !0;
      }
    }
}
u.prototype = {
  Q() {
    return this.F.concat();
  },
};
function B(b, c, l, k) {
  b.T.push([c.id, l.id, k.id]);
}
function w(b, c) {
  function l(a, b) {
    return Math.abs(a.x - b.x) < r.c.n && Math.abs(a.y - b.y) < r.c.n;
  }
  function k(a, b, c) {
    if (Math.abs(r.c.N(b, a, c)) > r.c.n) return !1;
    let d;
    Math.abs(a.y - b.y) < r.c.n
      ? ((d = b.x), a.x < c.x ? ((b = a.x), (a = c.x)) : ((b = c.x), (a = a.x)))
      : ((d = b.y),
        a.y < c.y ? ((b = a.y), (a = c.y)) : ((b = c.y), (a = a.y)));
    return b - d < r.c.n && d - a < r.c.n;
  }
  for (var a = [], e, d, f, h = 0; h < c.length; h++)
    (e = D(b, c[h].x, c[h].y)),
      (d = !0),
      (f = a.length - 1),
      f >= 0 &&
        (l(e, a[f]) ? (d = !1) : f > 0 && k(a[f - 1], a[f], e) && a.pop()),
      d && a.push(e);
  f = a.length - 1;
  f > 0 && l(a[f], a[0]) && (a.pop(), f--);
  f > 1 &&
    (k(a[f - 1], a[f], a[0]) && (a.pop(), f--),
    f > 1 && k(a[f], a[0], a[1]) && a.shift());
  return a;
}
function x(b, c, l) {
  return {
    O: b.L,
    a: c,
    i: l,
    p: r.c.G(l, c) == 1,
    o: null,
    m: null,
    H: null,
    I: null,
    v: !1,
    J: null,
    K: null,
    j: null,
    g: null,
    w: !1,
  };
}
function D(b, c, l) {
  c = { id: b.U.length, x: c, y: l };
  b.U.push(c);
  return c;
}
function E(b) {
  this.k = b;
}
E.prototype = {};
function F(b, c, l, k) {
  this.q = b || { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY };
  this.l = c || { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY };
  this.t = l;
  this.s = k;
  this.depth = -1;
}
F.prototype = {};
function G(b) {
  const c = new F(b.q, b.l, b.t, b.s);
  c.e = b.e;
  c.f = b.f;
  c.b = b.b;
  c.d = b.d;
  c.u = b.u;
  return c;
}
function H(b) {
  this.A = b;
  b.u = this;
}
H.prototype = {};
function I(b) {
  let c = new F(null, null, null, null);
  this.B = [];
  J(this, c);
  this.root = new H(c);
  if (b)
    for (b = b.r, c = 0; c < b.length; c++)
      (b[c].H = b[c].I = this.root), (b[c].v = !1);
}
I.prototype = {
  P(b) {
    let c;

    var l;

    var k = b.U.length;

    var a = Array(k);
    for (c = 0; c < k; c++) a[c] = Array(8);
    let e = Array(k);
    c = 0;
    for (l = this.B.length; c < l; c++) {
      var d = this.B[c];

      var f = d.e ? (d.f ? 5 : 7) : d.f ? 4 : 6;

      var h = d.b ? (d.d ? 1 : 0) : d.d ? 3 : 2;
      if (d.depth % 2 == 1) {
        if (f == 5 || h == 1 || (f == 7 && h == 3) || (f == 4 && h == 0)) {
          var g;
          g = { a: d.l, i: d.q, j: null, g: null, w: !1 };
          b.X.push(g);
          var p;
          p = { a: d.q, i: d.l, aa: g, j: null, g: null, w: !1 };
          b.X.push(p);
          g.aa = p;
          a[d.l.id][h] = g;
          a[d.q.id][f] = p;
        }
      } else
        d.q.id !== null && (e[d.q.id] = f), d.l.id !== null && (e[d.l.id] = h);
    }
    let t;
    for (c = 0; c < k; c++)
      if (((d = a[c]), (f = e[c]), f != null)) {
        l = f;
        h = null;
        do
          if ((l++ > 7 && (l = 0), (b = d[l])))
            h ? ((b.j = h), (h.g = b)) : ((t = b.a), (t.Y = b)), (h = b.aa);
        while (l != f);
        h && (t.Z = h);
      }
  },
};
function L(b, c) {
  function l() {
    const a = m.e || m.f;
    a.b && a.d
      ? m == a.b
        ? ((n.e = null), (a.b = q))
        : ((q.f = null), (a.d = n))
      : ((n.e = null), (n.f = a), (a.d = n));
  }
  function k(a) {
    m.l == t.l
      ? (f
          ? m.b
            ? ((a.e = q), (q.b = a), (n.d = null))
            : ((a.f = n), (q.b = null), (n.d = a))
          : ((a.e = q), (a.f = n), (q.b = n.d = a)),
        (q.d = n.b = null))
      : (a.e &&
          a.f &&
          (a.e == m ? ((a.C = a.f), (a.ba = !0)) : ((a.C = a.e), (a.ba = !1))),
        (a.e = q),
        (a.f = n),
        (q.d = n.b = a),
        (q.b = n.d = null));
  }
  function a() {
    let a;
    if (m.l == t.l && f)
      (m.b.e = q),
        (m.d.f = n),
        (q.b = m.b),
        (n.d = m.d),
        (a = q.d = n.b = null);
    else {
      m.b.e = q;
      m.d.f = n;
      var b = M(c, m.l);
      if (b > 0) a = !0;
      else if (b < 0) a = !1;
      else {
        a = m.b.s;
        let d = a.p;

        var b = d ? a.a : a.i;

        var b = M(c, b);
        b > 0
          ? (a = !0)
          : b < 0
            ? (a = !1)
            : ((a = d ? a.m : a.o),
              (b = d ? a.i : a.a),
              (b = M(c, b)),
              (a = b > 0 ? !0 : !1));
      }
      a
        ? ((a = m.d), (m.d.e = q), (q.b = m.b), (n.d = null))
        : ((a = m.b), (m.b.f = n), (n.d = m.d), (q.b = null));
      q.d = n.b = a;
    }
    return a;
  }
  N(c);
  let e;
  let d;
  let f;
  let h;
  let g;
  let p;
  c.p
    ? ((e = c.a), (h = c.i), (d = c.H), (g = c.I), (f = c.o.v), (p = c.m.v))
    : ((e = c.i), (h = c.a), (d = c.I), (g = c.H), (f = c.m.v), (p = c.o.v));
  p || ((p = O(b, g, h, !1)), g == d && (d = p), (g = p));
  g = g.A;
  if (g.e || g.f)
    if (g.q != h) console.log('ERR add_segment: trFirstHigh != segHigh: ', g);
    else {
      f || (d = O(b, d, e, !0));
      var t = d.A;

      var m = g;

      var q;

      var n;

      let y;

      let v;
      for (e = b.B.length + 2; m; ) {
        if (--e < 0) {
          console.log('ERR add_segment: infinite loop', m, c, b);
          return;
        }
        if (!m.b && !m.d) {
          console.log('ERR add_segment: missing successors', m, c, b);
          return;
        }
        d = m.u;
        d.h = c;
        d.A = null;
        v && v.s == m.s
          ? ((q = m),
            (n = v),
            (n.l = m.l),
            (d.left = new H(q)),
            (d.right = v.u))
          : (y && y.t == m.t
              ? ((n = m), (q = y), (q.l = m.l), (d.left = y.u))
              : ((q = m), (n = P(b, m)), (d.left = new H(q))),
            (d.right = new H(n)));
        m.e && m.f
          ? m.C
            ? (m.ba
                ? ((n.e = m.f), (n.f = m.C), (n.e.b = n), (n.f.d = n))
                : ((q.f = m.e), (q.e = m.C), (q.e.b = q), (q.f.d = q)),
              (q.C = n.C = null))
            : m.q == g.q
              ? ((n.f.d = n), (q.f = n.e = null))
              : n == m
                ? ((n.e = n.f), (n.f = null), (n.e.b = n))
                : ((q.f = q.e), (q.e = null))
          : l();
        m.b && m.d ? (d = a()) : ((d = m.b ? m.b : m.d), k(d));
        q.s && (q.s.J = n);
        n.t && (n.t.K = q);
        q.s = n.t = c;
        c.J = q;
        c.K = n;
        m.l != t.l ? ((y = q), (v = n), (m = d)) : (m = null);
      }
      c.v = !0;
    }
  else console.log('ERR add_segment: missing trFirst.uX: ', g);
}
function Q(b, c) {
  let l;
  let k;
  let a;
  c ? ((l = b.a), (k = b.i), (a = b.H)) : ((l = b.i), (k = b.a), (a = b.I));
  for (var e; a; )
    if (a.V) a = r.c.G(l == a.V ? k : l, a.V) == -1 ? a.left : a.right;
    else if (a.h) {
      if (l == a.h.a || l == a.h.i)
        if (Math.abs(l.y - k.y) < r.c.n) {
          a =
            Math.abs(a.h.a.y - a.h.i.y) < r.c.n
              ? l == a.h.a
                ? ((e = b.p ? k.x >= a.h.i.x : k.x < a.h.i.x)
                  ? b.o.p
                  : a.h.m.p)
                  ? a.right
                  : a.left
                : ((e = b.p ? k.x < a.h.a.x : k.x >= a.h.a.x)
                  ? b.m.p
                  : a.h.o.p)
                  ? a.left
                  : a.right
              : k.x < l.x
                ? a.left
                : a.right;
          continue;
        } else
          (e = M(a.h, k)),
            e === 0 &&
              (e =
                l == a.h.a
                  ? (e = b.p ? k.y >= a.h.i.y : k.y < a.h.i.y)
                    ? M(a.h, b.o.a)
                    : -M(a.h, a.h.m.i)
                  : (e = b.p ? k.y < a.h.a.y : k.y >= a.h.a.y)
                    ? M(a.h, b.m.i)
                    : -M(a.h, a.h.o.a));
      else
        (e = M(a.h, l)),
          e === 0 &&
            ((e = M(a.h, k)), e === 0 && (e = M(a.h, c ? b.o.a : b.m.i)));
      if (e > 0) a = a.left;
      else if (e < 0) a = a.right;
      else break;
    } else {
      a.A || console.log('ptNode: unknown type', a);
      c ? (b.H = a) : (b.I = a);
      break;
    }
}
function N(b) {
  Q(b, !0);
  Q(b, !1);
}
function M(b, c) {
  let l;
  l = b.a.x - c.x;
  const k = b.i.x - c.x;

  let a = Math.abs(b.a.y - c.y) < r.c.n;
  if (Math.abs(b.i.y - c.y) < r.c.n) {
    if (a) return 0;
    l = k;
  } else if (!a) return b.p ? r.c.N(b.a, b.i, c) : r.c.N(b.i, b.a, c);
  return Math.abs(l) < r.c.n ? 0 : l;
}
function O(b, c, l, k) {
  const a = c.A;
  if (a.q == l || a.l == l) return c;
  const e = G(a);
  a.l = e.q = l;
  a.b = e;
  e.e = a;
  a.d = e.f = null;
  e.b && (e.b.e = e);
  e.d && (e.d.f = e);
  J(b, e);
  c.V = l;
  c.A = null;
  c.right = new H(a);
  c.left = new H(e);
  return k ? a.u : e.u;
}
function P(b, c) {
  const l = G(c);
  J(b, l);
  return l;
}
function J(b, c) {
  c.fa = b.B.length;
  b.B.push(c);
}
function V(b) {
  this.k = b;
  this.$ = new I(this.k);
}
V.prototype = {
  P() {
    return this.$.P(this.k);
  },
};
function W(b) {
  this.k = b;
  this.S = null;
}
W.prototype = {};
function X(b) {
  this.k = b;
}
X.prototype = {};
function Z() {
  this.M = null;
}
Z.prototype = {
  W() {
    this.M = null;
  },
  Q() {
    return this.M ? this.M.Q() : null;
  },
  ea(b, c) {
    this.W();
    if (!b || b.length === 0) return [];
    let l = new u(b);

    var k = c ? !1 : l.L == 1;
    if (k) {
      k = new E(l);
      a: {
        var a = k.k;

        var e = a.r[0];

        var d = e;

        var f = e;

        var h = 0;
        do (h += (f.a.x - f.i.x) * (f.a.y + f.i.y)), (f = f.m);
        while (f != e);
        if (h < 0) {
          do (d.j = d.m), (d = d.g = d.o);
          while (d != e);
          a.F[0] = !1;
        } else {
          do (d.j = d.o), (d = d.g = d.m);
          while (d != e);
        }
        for (e = a = e; a.g != a.j; ) {
          b: {
            var d = a.j.a.x;

            var f = a.j.a.y;

            var h = a.a.x;

            var g = a.a.y;

            var p = a.g.a.x;

            var t = a.g.a.y;

            var m = p - h;

            var q = t - g;

            var n = d - p;

            var y = f - t;

            var v = h - d;

            var K = g - f;
            if (r.c.n > v * q - m * K) d = !1;
            else {
              for (var Y = a.j.j, C = a.g; C != Y; ) {
                var C = C.g;

                var z = C.a.x;

                var A = C.a.y;

                var R = z - d;

                var S = A - f;
                if (R !== 0 || S !== 0) {
                  let T = z - h;

                  var U = A - g;
                  if (T !== 0 || U !== 0)
                    if (
                      ((z -= p),
                      (A -= t),
                      (z !== 0 || A !== 0) &&
                        m * U - q * T >= r.c.D &&
                        v * S - K * R >= r.c.D &&
                        n * A - y * z >= r.c.D)
                    ) {
                      d = !1;
                      break b;
                    }
                }
              }
              d = !0;
            }
          }
          if (d)
            B(k.k, a.j.a, a.a, a.g.a),
              (a.j.g = a.g),
              (a.g.j = a.j),
              (e = a = a.g);
          else if (((a = a.g), a == e)) {
            k = !1;
            break a;
          }
        }
        k = !0;
      }
    }
    if (!k) {
      k = new W(l);
      k.S = new V(k.k);
      e = k.S;
      a = e.k.r.concat();
      r.c.da(a);
      d = 0;
      f = e.k.L;
      if (f != 1)
        for (h = Array(f), g = a.concat(), p = 0; p < g.length; p++)
          (t = g[p].O), h[t] ? (a[f++] = g[p]) : ((a[d++] = g[p]), (h[t] = !0));
      d = a.length;
      f = e.$;
      h = 0;
      for (g = d; h < d; ) {
        g = Math.log(g) / Math.LN2;
        for (p = g > 1 ? Math.floor(d / g) : d; h < p; h++) L(f, a[h]);
        for (p = h; p < d; p++) N(a[p]);
      }
      var e = e.k;

      var f = [f.B[0]];

      var h = [];

      var s;

      var p = 0;
      do {
        for (t = p % 2 == 1; (g = f.pop()); )
          g.depth == -1 &&
            ((g.depth = p),
            g.e && f.push(g.e),
            g.f && f.push(g.f),
            g.b && f.push(g.b),
            g.d && f.push(g.d),
            (s = g.t) && s.J.depth == -1 && h.push(s.J),
            (s = g.s)) &&
            (s.K.depth == -1 && h.push(s.K), s.p != t && (e.F[s.O] = !1));
        f = h;
        h = [];
        p++;
      } while (f.length > 0);
      for (p = 0; p < d; p++) a[p].J = a[p].K = null;
      k.S.P();
      s = k.k;
      d = 0;
      for (f = s.r.length; d < f; d++) {
        a = s.r[d];
        s.F[a.O]
          ? ((e = a.i), (a.j = a.o), (a.g = a.m))
          : ((e = a.a), (a = a.m), (a.j = a.m), (a.g = a.o));
        if ((h = a.a.Z)) (h.g = a), (a.j = h), (a.a.Z = null);
        if ((h = e.Y)) (h.j = a), (a.g = h), (e.Y = null);
      }
      s = k.k;
      s.R = [];
      k = 0;
      for (a = s.r.length; k < a; k++)
        if (((e = s.r[k]), !e.w)) {
          a: {
            h = f = d = void 0;
            g = e;
            f = h = e.a;
            e.w = !0;
            for (e = e.g; (d = e.a); ) {
              if (e.w) {
                if (d == f) break;
                console.log('ERR unique_monotone: segment in two chains', f, e);
                e = null;
                break a;
              }
              e.w = !0;
              r.c.G(d, h) == 1 && ((h = d), (g = e));
              e = e.g;
            }
            e = g;
          }
          e && s.R.push(e);
        }
      s = k = new X(l);
      k = s.k.R;
      s.k.T = [];
      for (a = 0; a < k.length; a++)
        if (((f = k[a]), (e = f.j), (d = f.g), d.g == e)) B(s.k, f.a, d.a, e.a);
        else if (
          ((e = s),
          (d = f.g),
          (f = f.a),
          (h = [d.a]),
          (g = 0),
          (d = d.g),
          (p = d.a),
          p != f)
        ) {
          for (; p != f || g > 1; )
            if (g > 0)
              if (
                ((t = r.c.N(h[g], p, h[g - 1])),
                Math.abs(t) <= r.c.n &&
                  (p == f || r.c.G(h[g], p) == r.c.G(h[g], h[g - 1])) &&
                  (t = 1),
                t > 0)
              )
                B(e.k, h[g - 1], h[g], p), g--;
              else if (((h[++g] = p), p == f))
                for (
                  console.log(
                    'ERR uni-y-monotone: only concave angles left',
                    h
                  );
                  g > 1;

                )
                  g--, B(e.k, h[g - 1], h[g], h[g + 1]);
              else (d = d.g), (p = d.a);
            else (h[++g] = p), (d = d.g), (p = d.a);
          B(e.k, h[g - 1], h[g], p);
        }
    }
    this.M = l;
    return l.T.concat();
  },
};
r.REVISION = r.ca;
r.Math = r.c;
r.Triangulator = Z;
Z.prototype.clear_lastData = Z.prototype.W;
Z.prototype.get_PolyLeftArr = Z.prototype.Q;
Z.prototype.triangulate_polygon = Z.prototype.ea;

export default r;
